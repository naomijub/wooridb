<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WooriDB</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="WooriDB is a general purpose time serial database with some relation algebra">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="sec-1-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="sec-2-installation.html"><strong aria-hidden="true">2.</strong> Installation and Important Information</a></li><li class="chapter-item expanded "><a href="sec-3-features.html"><strong aria-hidden="true">3.</strong> Features</a></li><li class="chapter-item expanded "><a href="sec-4-wql.html"><strong aria-hidden="true">4.</strong> WQL</a></li><li class="chapter-item expanded "><a href="sec-5-auth.html"><strong aria-hidden="true">5.</strong> Authorization and Authentication</a></li><li class="chapter-item expanded "><a href="sec-6-tx.html"><strong aria-hidden="true">6.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="sec-7-queries.html"><strong aria-hidden="true">7.</strong> Queries</a></li><li class="chapter-item expanded "><a href="sec-8-history.html"><strong aria-hidden="true">8.</strong> Entity History</a></li><li class="chapter-item expanded "><a href="sec-9-errors.html"><strong aria-hidden="true">9.</strong> Errors Messages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">WooriDB</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/naomijub/wooridb/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>WooriDB is a general purpose (<strong>EXPERIMENTAL</strong>) time serial database, which means it contains all entities registries indexed by DateTime and <code>Uuid</code>. It is schemaless, deep key-value storage and uses its own query syntax that is similar to SparQL and Crux's Datalog. </p>
<h2 id="name-origin"><a class="header" href="#name-origin">Name origin</a></h2>
<p><code>Woori</code> means <code>our</code>, in Korean, and although I developed this DB initially alone, it is in my culture and my hunsband's culture to call everything that is done for our communities and by our communities <strong>ours</strong>. I chose <em>Woori</em> instead of <em>shelanu</em> or <em>bizdin</em> because it easier to pronunce.</p>
<h2 id="project-inspirations"><a class="header" href="#project-inspirations">Project inspirations</a></h2>
<ul>
<li><a href="https://github.com/juxt/crux">Crux</a> a general purpose bitemporal graph query database with support for SQL and Datalog. It was the ideallogical source of WooriDB. I had developed a rust client called <a href="https://github.com/naomijub/transistor">Transistor</a> which gave me the basis of what I wanted to have in WooriDB.</li>
<li><a href="https://www.datomic.com/">Datomic</a> is a transactional database with a flexible data model, temporality and rich queries. I worked with Datomic at <a href="https://nubank.com.br/sobre-nos/">Nubank</a> and it is the reason I found Juxt/Crux. </li>
<li><a href="https://github.com/prometheus/prometheus">Prometheus</a> An open-source monitoring system with a dimensional data model, flexible query language, efficient <strong>time series database</strong> and modern alerting approach.</li>
<li><a href="https://en.wikipedia.org/wiki/SPARQL">SparQL</a> SPARQL is a query language for  RDF graph databases, it is flexible enough for query information based on datetime indexes. </li>
<li>Book <a href="https://www.amazon.com.br/Database-Internals-Alex-Petrov/dp/1492040347/ref=sr_1_1?__mk_pt_BR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;dchild=1&amp;keywords=Database+Internals%3A&amp;qid=1612831621&amp;sr=8-1">Database Internals</a></li>
<li>Book <a href="https://www.amazon.com.br/dp/B073MPV4YC/ref=dp-kindle-redirect?_encoding=UTF8&amp;btkr=1">Database System Concept</a></li>
<li>Book <a href="https://www.amazon.com.br/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/ref=sr_1_1?__mk_pt_BR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;dchild=1&amp;keywords=Designing+Data%E2%80%93Intensive+Applications&amp;qid=1612831724&amp;s=books&amp;sr=1-1">Designing Data Intensive Application</a></li>
<li>Professor <a href="http://www.cs.cmu.edu/%7Epavlo/">Andy Pavlo</a> Database Design Course. </li>
</ul>
<h2 id="naming-conventios"><a class="header" href="#naming-conventios">Naming conventios:</a></h2>
<ul>
<li>Entity Tree is similar to SQL table, it is the data structure that contains all ids and entities map relations.</li>
<li>Entity ID is the id of an entity inside Entity tree.</li>
<li>Entity map is the content of and entity associated with the entity id.</li>
</ul>
<h1 id="installation-and-important-information"><a class="header" href="#installation-and-important-information">Installation and Important Information</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>To run WooriDB it is necessary to have Rust installed in the machine. There are two ways to do this:</p>
<ol>
<li>Go to rustup.rs and copy the command there, for unix it is <code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code>.</li>
<li>Clone WooriDB and execute <code>make setup</code>.</li>
</ol>
<h3 id="executing-wooridb"><a class="header" href="#executing-wooridb">Executing WooriDB</a></h3>
<ul>
<li><code>Release mode performance</code>: <code>make release</code> in project root for performance optimization.</li>
<li><code>Release mode size</code>: <code>make run</code> in project root for size optimization.</li>
<li><code>Debug mode</code>: <code>make debug</code> in project root.</li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>you can find the latest docker image at <strong><a href="https://hub.docker.com/repository/docker/naomijubs/wooridb">naomijub/wooridb</a></strong>. The current most stable tag is <strong><code>beta-2</code></strong>. To execute the docker container run:</p>
<ul>
<li><code>docker run -p 1438:1438 naomijubs/wooridb:beta-2 debug</code> for debug mode.</li>
<li><code>docker run -p 1438:1438 -e AUTH_HASHING_COST=8 -e ADMIN=your-admin-id -e ADMIN_PASSWORD=your-admin-pswd naomijubs/wooridb:beta-2 run</code>  for size optimization.</li>
<li><code>docker run -p 1438:1438 -e AUTH_HASHING_COST=8 -e ADMIN=your-admin-id -e ADMIN_PASSWORD=your-admin-pswd naomijubs/wooridb:beta-2 release</code> for performance optimization.</li>
<li>All <code>-e/--env</code> can be replaced by a <code>--env-file path/to/your/.env</code>. Your <code>.env</code>file should contain the following fields:</li>
</ul>
<pre><code>HASHING_COST=16
PORT=1438
AUTH_HASHING_COST=8
ADMIN=your-admin-id
ADMIN_PASSWORD=your-admin-pswd
</code></pre>
<h2 id="important-information"><a class="header" href="#important-information">Important Information</a></h2>
<ul>
<li>Responses are in <a href="https://github.com/ron-rs/ron"><code>RON</code></a> format.</li>
<li><code>BLOB</code> will not be supported. Check out <a href="https://www.microsoft.com/en-us/research/publication/to-blob-or-not-to-blob-large-object-storage-in-a-database-or-a-filesystem/">To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem</a>.</li>
</ul>
<h3 id="configurations"><a class="header" href="#configurations">Configurations</a></h3>
<ul>
<li>To run the project in <code>debug</code> mode it is important to export the following environment variables <code>HASHING_COST, PORT</code>. Default values are:</li>
</ul>
<pre><code>HASHING_COST=16
PORT=1438
</code></pre>
<ul>
<li>To run the project in <code>release</code> mode it is important to export the following environment variables <code>HASHING_COST, PORT, AUTH_HASHING_COST, ADMIN, ADMIN_PASSWORD</code>. There are no default values for <code>AUTH_HASHING_COST, ADMIN, ADMIN_PASSWORD</code>.</li>
</ul>
<h1 id="features"><a class="header" href="#features">Features</a></h1>
<ul>
<li>Sintax inspired by SparQL and Crux's datalog.</li>
<li>Entities are indexed by date(time).</li>
<li>Schemaless.</li>
<li>Deep Key-value storage, which means that you can have key values inside hashmap values.</li>
<li>Hashing entity map keys content with <a href="https://github.com/naomijub/wooridb#create-entity"><code>ENCRYPT</code></a>.</li>
<li>Unique entity maps keys content with <a href="https://github.com/naomijub/wooridb#create-entity"><code>UNIQUE</code></a> for an entity tree.</li>
<li>Hashed values are filtered out of <code>SELECT</code> and can only be checked with  <a href="https://github.com/naomijub/wooridb#checks-validity-of-of-an-encrypted-key"><code>CHECK</code></a> keyword.</li>
<li><a href="https://github.com/ron-rs/ron/blob/master/docs/grammar.md"><code>Ron</code></a> schemas for input and output.
<ul>
<li><input disabled="" type="checkbox"/>
JSON to be supported via feature.</li>
<li><input disabled="" type="checkbox"/>
EDN to be supported via feature.</li>
</ul>
</li>
<li>Entities are also indexed by <code>entity_name</code> (entity tree key) and <code>Uuid</code> (entity id). Entity map format is a HashMap where keys are strings and values are supported <a href="https://github.com/naomijub/wooridb/blob/main/wql/src/lib.rs#L78"><code>Types</code></a>.</li>
<li>Stores persistent data locally.
<ul>
<li><input disabled="" type="checkbox"/>
<code>S3</code> as a backend is to be developed.</li>
<li><input disabled="" type="checkbox"/>
<code>Postgres</code> as a backend is to be developed.</li>
<li><input disabled="" type="checkbox"/>
<code>DynamoDB</code> as a backend is to be developed.</li>
</ul>
</li>
<li>Able to handle very large numbers when using the <code>P</code> suffix.
<ul>
<li>Ex: <code>98347883122138743294728345738925783257325789353593473247832493483478935673.9347324783249348347893567393473247832493483478935673P</code>.</li>
</ul>
</li>
<li>Configuration is done via environment variables.
<ul>
<li><input disabled="" type="checkbox"/>
CORS</li>
</ul>
</li>
<li>Authentication and Authorization via session token
<ul>
<li><input disabled="" type="checkbox"/>
Creating and removing ADMINs.</li>
<li><input disabled="" type="checkbox"/>
Removing Users.</li>
</ul>
</li>
<li><a href="https://github.com/naomijub/wooridb#match-update-entity">Conditional Update</a></li>
<li><input disabled="" type="checkbox"/>
File compression done with <code>zstd</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Entity id history</li>
<li><input disabled="" type="checkbox"/>
Possible Relation Algebra
<ul>
<li><input disabled="" type="checkbox"/>
Projection</li>
<li><input disabled="" type="checkbox"/>
Union</li>
<li><input disabled="" type="checkbox"/>
Intersection</li>
<li><input disabled="" type="checkbox"/>
Difference (SQL's EXCEPT?)</li>
<li><input disabled="" type="checkbox"/>
Join</li>
<li><input disabled="" type="checkbox"/>
Product (SQL's CROSS JOIN?)</li>
<li><input disabled="" type="checkbox"/>
Rename</li>
<li><input disabled="" type="checkbox"/>
Assign</li>
<li><input disabled="" type="checkbox"/>
Dedup</li>
<li><input disabled="" type="checkbox"/>
Sort</li>
<li><input disabled="" type="checkbox"/>
Aggregate</li>
<li><input disabled="" type="checkbox"/>
Division</li>
</ul>
</li>
</ul>
<h2 id="naming-conventios-1"><a class="header" href="#naming-conventios-1">Naming conventios:</a></h2>
<ul>
<li>Entity Tree is similar to SQL table, it is the data structure that contains all ids and entities map relations.</li>
<li>Entity ID is the id of an entity inside Entity tree.</li>
<li>Entity map is the content of and entity associated with the entity id.</li>
</ul>
<h1 id="woori-query-language"><a class="header" href="#woori-query-language">Woori Query Language</a></h1>
<p><a href="https://github.com/naomijub/wooridb/tree/main/wql">Woori Query language</a> or <code>WQL</code> is WooriDB's Query Language and it is inspired by SparQL, Datalog and SQL. Its main features are:</p>
<p><strong>Transactions</strong></p>
<ul>
<li><code>CREATE</code> entity tree key by name.
<ul>
<li><code>UNIQUE</code>: With unique values for entity map keys inside entity tree.</li>
<li><code>ENCRYPTS</code>: With encrypted values for defined key-values inside entity map.</li>
</ul>
</li>
<li><code>INSERT</code> entity map into entity tree.</li>
<li><code>UPDATE</code>s with <code>SET</code> or <code>CONTENT</code> entity map.
<ul>
<li>SET UPDATE replaces the sent entity map as the entity's map content.</li>
<li>CONTENT UPDATE updates numerical and string the current entity's map content with the sent entity map value and the other values work the same way as SET. </li>
</ul>
</li>
<li><code>MATCH UPDATE</code> updates entity map content with new content if match condition is satisfied.</li>
<li><code>DELETE</code>s the last entity map content for and entity id.</li>
<li><code>EVICT</code>
<ul>
<li>Evicts specific entity id and entity map</li>
<li>Evicts all entities in the entity tree key.</li>
</ul>
</li>
</ul>
<p><strong>Queries</strong></p>
<ul>
<li><code>SELECT</code> the only way to retrieve entity's content.</li>
<li><code>CHECK</code> the only way to verify keys that are encrypted.</li>
</ul>
<blockquote>
<p>ALL DATA STRUCTURES HASHMAPS, HASHSETS AND LIST MUST CONTAIN A <code>,</code> AFTER EACH ELEMENT. Example <code>#{name, ssn,}</code> is valid but <code>#{name, ssn}</code> is not valid.</p>
</blockquote>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="create"><a class="header" href="#create">CREATE</a></h3>
<p>Creates an entity tree key.</p>
<ul>
<li><code>CREATE ENTITY my_entity</code> this will create an entity tree key named <code>my_entity</code>, in SQL terms it means <code>CREATE TABLE my_entity</code>.</li>
<li><code>CREATE ENTITY my_entity UNIQUES #{name, ssn,}</code> the entity tree key named <code>my_entity</code> will only allow unique values for the entities keys <code>name</code> and <code>ssn</code> in its maps.</li>
<li><code>CREATE ENTITY my_entity ENCRYPTS #{pswd,}</code> the entity tree key named <code>my_entity</code> will encrypt the entities keys that are <code>pswd</code>. The hashing cost of the encrypt is defined by the environment variable <code>HASHING_COST</code>, recommended is between 10 and 14.</li>
<li>Encryted keys cannot be uniques so <code>CREATE ENTITY my_entity UNIQUES #{name, ssn, pswd,} ENCRYPTS #{pswd,}</code> is invalid but <code>CREATE ENTITY my_entity UNIQUES #{name, ssn,} ENCRYPTS #{pswd,}</code> is valid.</li>
</ul>
<h3 id="insert"><a class="header" href="#insert">INSERT</a></h3>
<p>Inserts an entity id and an entity map into entity tree key.</p>
<ul>
<li><code>INSERT {a: 123, b: &quot;hello julia&quot;,} INTO entity_key</code> this will insert the entity map <code>{a: 123, b: &quot;hello julia&quot;,}</code> (key <code>a</code> containing as <code>Type::Integer(123)</code> and key <code>b</code> containing a <code>Type::String(&quot;hello julia&quot;)</code>) and a random Uuid for entity ID into entity tree key <code>entity_key</code>.</li>
</ul>
<p>To INSERT entity with a predefined <code>Uuid</code> it is necessary to use the keyword <code>WITH</code> after the entity tree key followed by as Uuid-V4. <code>INSERT {a: 123, b: &quot;hello julia&quot;,} INTO entity_key WITH 4f6fccb0-20fb-4d8e-af7c-65db30f4954a</code>.</p>
<h3 id="update-set"><a class="header" href="#update-set">UPDATE SET</a></h3>
<p>Updates the content by replacing the previous entity map in entity tree key <code>my_entity_name</code> with the entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code>.</p>
<ul>
<li><code>UPDATE my_entity_name SET {a: -4, b: 32,} INTO 48c7640e-9287-468a-a07c-2fb00da5eaed</code> this will replace the current entity map stored in entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code>.</li>
</ul>
<h3 id="update-content"><a class="header" href="#update-content">UPDATE CONTENT</a></h3>
<p>Updates the content by numerical addition or string concatenation of the previous entity map in entity tree key <code>my_entity_name</code> with the entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code>. Non numerical or non string value will just be replaced. If key doesn't  exist it will be created.</p>
<ul>
<li><code>UPDATE my_entity_name CONTENT {a: -4, b: 32,} INTO 48c7640e-9287-468a-a07c-2fb00da5eaed</code> this will add <code>-4</code> to entity map key <code>a</code> and add <code>32</code> to entity map key <code>b</code> in the current entity map stored in entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code>.</li>
</ul>
<h3 id="match-update"><a class="header" href="#match-update">MATCH UPDATE</a></h3>
<p>Similar to SET, but it requires a pre-condition to be satisfied.</p>
<ul>
<li><code>MATCH ALL(a == 1, b &gt;= 3, c != \&quot;hello\&quot;, d &lt; 7,) UPDATE this_entity SET {a: 123, g: NiL,} INTO d6ca73c0-41ff-4975-8a60-fc4a061ce536</code> if all conditions defined inside <code>ALL</code> are satisfied the set update will happen.
<ul>
<li><code>ALL</code> is an logical <code>and</code> between all conditions, meaning that all of them must be true.</li>
<li><code>ANY</code> is an logical <code>or</code> between all conditions, meaning that at least one of them must be true.</li>
<li><strong>NULL KEYS</strong>, <code>ALL</code> returns an error if a null key is present and <code>ANY</code> just ignores null keys.</li>
<li>Possible conditions are:
<ul>
<li><code>==</code> means equals, so if <code>a == 100</code>, this means that the entity map key <code>a</code> must equals to <code>100</code>.</li>
<li><code>!=</code> means not equals, so if <code>a != 100</code>, this means that the entity map key <code>a</code> must not equals to <code>100</code>.</li>
<li><code>&gt;=</code> means greater or equal, so if <code>a &gt;= 100</code>, this means that the entity map key <code>a</code> must br greater or equals to <code>100</code>.</li>
<li><code>&lt;=</code> means lesser or equal, so if <code>a &lt;= 100</code>, this means that the entity map key <code>a</code> must be lesser or equals to <code>100</code>.</li>
<li><code>&gt;</code> means greater, so if <code>a &gt; 100</code>, this means that the entity map key <code>a</code> must be greater than <code>100</code>. </li>
<li><code>&lt;</code> means lesser, so if <code>a &lt; 100</code>, this means that the entity map key <code>a</code> must be lesser than <code>100</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="delete"><a class="header" href="#delete">DELETE</a></h3>
<p>Deletes the last entity map event for an entity ID in entity tree key, that is, it deletes the last state of an entity map.</p>
<ul>
<li><code>DELETE 48c7640e-9287-468a-a07c-2fb00da5eaed FROM my_entity_name</code> this will delete the last state of entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code> in entity tree key <code>my_entity_name</code> from entity history.</li>
</ul>
<h3 id="evict"><a class="header" href="#evict">EVICT</a></h3>
<p>Removes all occurrences of an entity from the entity tree. It can be just the entity id or the whole entity tree key.</p>
<ul>
<li><code>EVICT 48c7640e-9287-468a-a07c-2fb00da5eaed FROM my_entity_name</code> removes all occurrences of the entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code> from the entity tree key <code>my_entity_name</code>, they cannot be queried anymore.</li>
<li><code>EVICT my_entity</code> removes the key <code>my_entity</code> from the entity tree. It cannot be queried anymore. It is similar to SQL's <code>DROP TABLE my_entity</code>.</li>
</ul>
<h3 id="check"><a class="header" href="#check">CHECK</a></h3>
<p>Checks for encrypted key data validity. This transaction only works with keys that are encrypted and it serves  as a way to verify if the passed values are <code>true</code> of <code>false</code> against encrypted data. </p>
<ul>
<li><code>CHECK {pswd: &quot;my-password&quot;, ssn: 3948453,} FROM my_entity_name ID 48c7640e-9287-468a-a07c-2fb00da5eaed</code> this will check if keys <code>psdw</code> and <code>ssn</code> from entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code> in entity tree key <code>my_entity_name</code> have the values <code>&quot;my-password&quot;</code> for pswd and <code>3948453</code> for ssn.</li>
</ul>
<h3 id="select"><a class="header" href="#select">SELECT</a></h3>
<p>This is the way to query entities from WooriDB. Similar to SQL and SparQL <code>SELECT</code>.</p>
<p>Possible <code>SELECT</code>  combinantions:</p>
<ul>
<li><code>SELECT * FROM my_entity_name</code> selects all entity ids and entity maps for the entity tree key <code>my_entity_name</code> with all the possible entities map keys.</li>
<li><code>SELECT #{name, last_name, age,} FROM my_entity_name</code> selects all entity ids and entity maps for the entity tree key <code>my_entity_name</code> with only the keys <code>name, last_name, age</code> for the entities map.</li>
<li><code>SELECT * FROM my_entity_name ID 48c7640e-9287-468a-a07c-2fb00da5eaed</code> selects the entity map containing the entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code> from the entity tree key <code>my_entity_name</code> with all the possible entities map keys.</li>
<li><code>SELECT #{name, last_name, age,} FROM my_entity_name ID 48c7640e-9287-468a-a07c-2fb00da5eaed</code> selects the entity map containing the entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code> from the entity tree key <code>my_entity_name</code> with only the keys <code>name, last_name, age</code> for the entities map.</li>
<li><code>SELECT * FROM my_entity_name IDS IN #{48c7640e-9287-468a-a07c-2fb00da5eaed, 57c7640e-9287-448a-d07c-3db01da5earg, 54k6640e-5687-445a-d07c-5hg61da5earg,}</code> this will return the entities map containing the entities ids <code>#{48c7640e-9287-468a-a07c-2fb00da5eaed, 57c7640e-9287-448a-d07c-3db01da5earg, 54k6640e-5687-445a-d07c-5hg61da5earg,}</code> from entity tree key <code>my_entity_name</code>. Keys set is available.</li>
<li><code>Select * FROM my_entity ID 0a1b16ed-886c-4c99-97c9-0b977778ec13 WHEN AT 2014-11-28T21:00:09+09:00</code> this will select the last entity map state for the entity id <code>0a1b16ed-886c-4c99-97c9-0b977778ec13</code> in entity tree key <code>my_entity</code> at date <code>2014-11-28</code>. Requires to use DateTime UTC, for now.</li>
<li><code>SELECT * FROM entity_name ID &lt;uuid&gt; WHEN START 2014-11-28T09:00:09Z END 2014-11-28T21:00:09Z</code> this will select the all entity map states for the entity id <code>0a1b16ed-886c-4c99-97c9-0b977778ec13</code> in entity tree key <code>my_entity</code> in the time range starting at <code>2014-11-28T09:00:09Z</code> and ending at <code>2014-11-28T21:00:09Z</code>.</li>
<li><code>SELECT * FROM my_entity WHERE { ?* my_entity:a ?a, ?* my_entity:c ?c, (== ?a 123),(or (&gt;= ?c 4300.0), (&lt; ?c 6.9),),}</code> this will select all enitities ids and entities maps from entity tree key <code>my_entity</code> that satisfy the where clause.
<ul>
<li><code>?* my_entity:a ?a</code> and <code>?* my_entity:c ?c</code> define that the entity keys <code>a</code> and <code>c</code> from entity tree key <code>my_entity</code> will receive the attributed value <code>?a</code> and <code>?c</code> repectively.</li>
<li><code>(== ?a 123)</code> selects all entities which entity map key <code>a</code> is equal to <code>123</code>.</li>
<li><code>(or (&gt;= ?c 4300.0), (&lt; ?c 6.9),)</code> selects all entities which entity map key <code>c</code> is greater or equal to <code>4300.0</code> <strong>or</strong> is smaller than <code>6.9</code>.</li>
</ul>
</li>
</ul>
<h4 id="where-clause"><a class="header" href="#where-clause">WHERE Clause</a></h4>
<p>Possible functions for the where clause:</p>
<ul>
<li><code>in</code>: <code>(in ?k1 123 34543 7645 435)</code>, <code>?k1</code> must be present in the set containing <code>123 34543 7645 435</code>. NOTE: <strong>for now, please don't use <code>,</code></strong>.</li>
<li><code>between</code>: <code>(between ?k1 0 435)</code>, <code>?k1</code>  must be between starting value <code>0</code> and ending value <code>435</code>. If you set more than 2 arguments it will return a <code>ClauseError</code>.</li>
<li><code>like</code>: <code>(like ?k2 &quot;%naomi%&quot;)</code>, like is comparing <code>?k2</code> with the string <code>&quot;%naomi%&quot;</code> considering that <code>%</code> are wildcards. <code>&quot;%naomi&quot;</code> means <code>end_with(&quot;naomi&quot;)</code>, <code>&quot;naomi%&quot;</code> means <code>starts_with(&quot;naomi&quot;)</code> and <code>&quot;%naomi%&quot;</code> means <code>contains(&quot;naomi&quot;)</code>. Possible regex support in the future.</li>
<li><code>==</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code> -&gt; <code>(&gt;= ?k1 0)</code> which means <em>get all values that <code>?k1</code> is greater than or equal to <code>0</code></em>.</li>
<li><code>or</code>: All arguments inside the <code>or</code> function call will be evaluated to <code>true</code> if any of them is <code>true</code>. </li>
</ul>
<h4 id="relation-algebra"><a class="header" href="#relation-algebra">Relation Algebra</a></h4>
<p>Some relation algebra may be implemented:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Projection</li>
<li><input disabled="" type="checkbox"/>
Union</li>
<li><input disabled="" type="checkbox"/>
Intersection</li>
<li><input disabled="" type="checkbox"/>
Difference (SQL's EXCEPT?)</li>
<li><input disabled="" type="checkbox"/>
Join</li>
<li><input disabled="" type="checkbox"/>
Product (SQL's CROSS JOIN?)</li>
<li><input disabled="" type="checkbox"/>
Assign</li>
<li><input disabled="" type="checkbox"/>
Dedup</li>
<li><input disabled="" type="checkbox"/>
Sort</li>
<li><input disabled="" type="checkbox"/>
Aggregate</li>
<li><input disabled="" type="checkbox"/>
Division</li>
</ul>
<h3 id="entity-map-value-types"><a class="header" href="#entity-map-value-types">Entity map value TYPES</a></h3>
<blockquote>
<p><strong>Types Notes</strong></p>
<ol>
<li>
<p><strong>Precise floats</strong> or <strong>numbers larger than f64::MAX/i128::MAX</strong> can be defined with an UPPERCASE <code>P</code> at the end. </p>
<ul>
<li><em>Note</em>: This type cannot be updated with <code>UPDATE CONTENT</code>. </li>
<li>Ex.: <code>INSERT {a: 98347883122138743294728345738925783257325789353593473247832493483478935673.9347324783249348347893567393473247832493483478935673P, } INTO my_entity</code>.</li>
</ul>
</li>
<li>
<p><code>BLOB</code> will not be supported. Check out <a href="https://www.microsoft.com/en-us/research/publication/to-blob-or-not-to-blob-large-object-storage-in-a-database-or-a-filesystem/">To BLOB or Not To BLOB: Large Object Storage in a Database or a Filesystem</a></p>
</li>
</ol>
</blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<code>Char(char)</code> contains the type char defined by <code>'c'</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Integer(isize)</code> contains the type isize, just a number without <code>.</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>String(String)</code> contains any value passed wuth <code>&quot;this is a string&quot;</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Uuid(Uuid)</code> contains an <code>Uuid V4</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Float(f64)</code> contains the type f64, any number containing <code>.</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Boolean(bool)</code> contains type boolean <code>true</code> of <code>false</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Vector(Vec&lt;Types&gt;)</code> contains a vector of <code>Types</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Map(HashMap&lt;String, Types&gt;)</code> contains a HashMap of key <code>String</code> and value <code>Types</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Hash(String)</code> contains a Hash generated by <code>ENCRYPTS</code>,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Precise(String)</code> contains a very large integer or a very large float,</li>
<li><input disabled="" type="checkbox" checked=""/>
<code>Nil</code> contains a <code>null/nil</code> value,</li>
<li><input disabled="" type="checkbox"/>
<code>DateTime</code> to be added.</li>
</ul>
<h1 id="authorization-and-authentication"><a class="header" href="#authorization-and-authentication">Authorization and Authentication</a></h1>
<p>Authentication and authorization only work with release mode, so <code>cargo run --release</code> is required. </p>
<p>Some environment variables are also required:</p>
<pre><code>AUTH_HASHING_COST=8 
ADMIN=your_admin
ADMIN_PASSWORD=your_password
</code></pre>
<ul>
<li><code>AUTH_HASHING_COST</code> is the hashing cost for password in the authentication system.</li>
<li><code>ADMIN</code> is the admin's user id.</li>
<li><code>ADMIN_PASSWORD</code> is the admin's user password.</li>
</ul>
<h2 id="creating-new-users"><a class="header" href="#creating-new-users">Creating new users</a></h2>
<ul>
<li><code>ADMIN</code> is the only user role capable of creating new users. For now there can only be one <code>ADMIN</code>.</li>
</ul>
<p>To create a new user, POST at <code>/auth/createUser</code> with your admin credentials and the new user info as follows (in RON format):</p>
<pre><code class="language-ron">(
  admin_id: &quot;your_admin&quot;,
  admin_password: &quot;your_password&quot;,
  user_info: (
    user_password: &quot;my_password&quot;,
    role: [User,],
  ),
)
</code></pre>
<p>User information consists of the user's password to be used and the user's roles. Remember to always put <code>,</code> at the end. 
Response to this request will be <code>(user_id: \&quot;&lt;some-uuid&gt;\&quot;,)</code>, containing the user's unique ID.</p>
<h3 id="available-user-roles-are"><a class="header" href="#available-user-roles-are">Available user roles are:</a></h3>
<ul>
<li><code>ADMIN</code> - works primarily at <code>/auth/createUser</code>.</li>
<li><code>USER</code> - works on all <code>/wql/query</code>, <code>/wql/tx</code> and <code>/auth/putUserSession</code>.</li>
<li><code>WRITE</code> - only works on <code>/wql/tx</code> and <code>/auth/putUserSession</code>.</li>
<li><code>READ</code> - only works on <code>/wql/query</code> and <code>/auth/putUserSession</code>.</li>
<li><code>HISTORY</code> - only works on <code>/entity-history</code>.</li>
<li>New roles to be added as needed.</li>
</ul>
<h3 id="getting-a-session-token"><a class="header" href="#getting-a-session-token">Getting a session token</a></h3>
<p>To make a request at WQL endpoints you need a session token that will expire within 3600 seconds. To retrieve a session token you need to <code>PUT</code> at endpoint <code>/auth/putUserSession</code> your user credentials as follows (in RON format):</p>
<pre><code class="language-ron">(id: &quot;&lt;user_id&gt;&quot;, user_password: &quot;&lt;user_password&gt;&quot;,)
</code></pre>
<p>Response will be a plain/text with your token.</p>
<h3 id="making-auth-requests-to-wqltx-and-wqlquery"><a class="header" href="#making-auth-requests-to-wqltx-and-wqlquery">Making auth requests to <code>/wql/tx</code> and <code>/wql/query</code>.</a></h3>
<p>To avoid authentication and authorization errors, add your token to the authorization bearer header, <code>Authorization: Bearer &lt;your session token&gt;</code>. 
Your user needs the correct session token and the correct role for this request.</p>
<h3 id="todos"><a class="header" href="#todos">TODOs:</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Adding other admins and removing admins is not yet implemented.</li>
<li><input disabled="" type="checkbox"/>
Configure session token expiration time.</li>
</ul>
<h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>Transaction is the name of all operations that change the database state, like <code>CREATE, INSERT, UPDATE, MATCH, DELETE, EVICT</code>. This is done by sending a <code>POST</code> request to endpoint <code>&lt;ip&gt;:1438/wql/tx</code>. An example request would be <code>curl -X POST -H &quot;Content-Type: application/wql&quot; &lt;ip&gt;:1438/wql/tx -d 'CREATE ENTITY my_entity'</code>. In <code>release mode</code> it is necessary to use header <code>Authorization: Bearer &lt;your session token&gt;</code> for this endpoint.</p>
<blockquote>
<p><strong>Reminder</strong>
A comma is required at the end of every data structure representation.
Ex.: <code>{a: 123, b: 456,}</code>, <code>#{a, b, c,}</code>, <code>(a, b, c,)</code>. 
No need for <code>;</code> at the end of each expression.</p>
</blockquote>
<h2 id="create-entity"><a class="header" href="#create-entity"><code>CREATE ENTITY</code></a></h2>
<p><a href="./sec-4-wql.html#create">CREATE WQL Reference</a></p>
<p>Similar to <code>CREATE TABLE</code> in SQL, it creates an entity tree which matches the table name. It requires an entity name like <code>my_entity_name</code> after <code>CREATE ENTITY</code>. </p>
<p>Example request: </p>
<pre><code class="language-sql">CREATE ENTITY my_entity_name
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 entity: &quot;my_entity_name&quot;,
 message: &quot;Entity `my_entity_name` created&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>CREATE ENTITY &lt;entity&gt; ENCRYPT #{keys...}</code>: When the system has encrypted keys, the <code>insert</code> and <code>upload</code> requests take longer due to hashing function and the verify function. This is determined by the hashing cost:</li>
</ul>
<pre><code>bench_cost_10      ... bench:  51,474,665 ns/iter (+/- 16,006,581)
bench_cost_14      ... bench: 839,109,086 ns/iter (+/- 274,507,463)
bench_cost_4       ... bench:     795,814 ns/iter (+/- 42,838)
bench_cost_default ... bench: 195,344,338 ns/iter (+/- 8,329,675)
* Note that I don't go above 14 as it takes too long. However, it is way safer, it is a trade-off. 
</code></pre>
<h2 id="insert-1"><a class="header" href="#insert-1"><code>INSERT</code></a></h2>
<p><a href="./sec-4-wql.html#insert">INSERT WQL Reference</a></p>
<p>Inserts a <strong>HashMap&lt;String, <a href="./sec-4-wql.html#entity-map-value-types">Types</a>&gt;</strong>  into the entity tree key previously created (<code>my_entity_name</code>). This request returns a <code>Uuid</code> containing the entity id. </p>
<p>Example request: </p>
<pre><code class="language-sql">INSERT {a: 123,  c: \&quot;hello\&quot;, d: \&quot;world\&quot;,} 
INTO my_entity_name
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 entity: &quot;my_entity_name&quot;,
 uuid: &quot;00d025c9-eda8-4190-a33a-29998bd77bd3&quot;,
 message: &quot;Entity my_entity_name inserted with Uuid 00d025c9-eda8-4190-a33a-29998bd77bd3&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<p>The request above will insert an entity with the following structure in <code>my_entity_name</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{&quot;my_entity_name&quot;: {
    Uuid(00d025c9-eda8-4190-a33a-29998bd77bd3): {a: 123, c: &quot;hello&quot;, d: &quot;world&quot;,},
}}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>To pre-define the Uuid of the entity to insert use <code>WITH</code> keyword followed by an Uuid-v4. This uuid will be used to identify the entity map in the entity tree. As follows:</li>
</ul>
<pre><code class="language-sql">INSERT {a: 123,  c: \&quot;hello\&quot;, d: \&quot;world\&quot;,} 
INTO my_entity_name
WITH &lt;ENTITY-UUID&gt;
</code></pre>
<h2 id="update"><a class="header" href="#update"><code>UPDATE</code></a></h2>
<p>Updates the content of an entity map for an entity tree key and an entity id. There are two possible updates:</p>
<h3 id="update-set-1"><a class="header" href="#update-set-1"><code>UPDATE SET</code></a></h3>
<p><a href="./sec-4-wql.html#update-set">UPDATE SET WQL Reference</a>
<code>SET</code> updates defines the current value of the entity map to the ones being passed, so if your entity map is <code>{a: 123, b: 12.5,}</code> and your set update has the hashmap <code>{a: 432, c: \&quot;hello\&quot;,}</code>, the current state of the entity map will be <code>{a: 432, b: 12.5, c: \&quot;hello\&quot;,}</code>. </p>
<p>Example request:</p>
<pre><code class="language-sql">UPDATE my_entity_name 
SET {a: -4, b: 32,} 
INTO 00d025c9-eda8-4190-a33a-29998bd77bd3
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 entity: &quot;my_entity_name&quot;,
 uuid: &quot;00d025c9-eda8-4190-a33a-29998bd77bd3&quot;,
 state: &quot;{\&quot;b\&quot;: Integer(32),\&quot;a\&quot;: Integer(-4),}&quot;,
 message: &quot;Entity my_entity_name with Uuid 00d025c9-eda8-4190-a33a-29998bd77bd3 updated&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<h3 id="update-content-1"><a class="header" href="#update-content-1"><code>UPDATE CONTENT</code></a></h3>
<p><a href="./sec-4-wql.html#update-content">UPDATE CONTENT WQL Reference</a>
<code>CONTENT</code> updates are a way to add numerical values and concatenate Strings, so if your entity map is <code>{a: 432, c: \&quot;hello\&quot;,}</code> and your content update has the hashmap <code>{a: -5, c: \&quot;world\&quot;, b: 12.5}</code> the current state of the entity map will be <code>{a: 427, c: \&quot;helloworld\&quot;, b: 12.5}</code>. </p>
<p>Example request:</p>
<pre><code class="language-sql">UPDATE my_entity_name 
CONTENT {a: -34, b: 7,} 
INTO 00d025c9-eda8-4190-a33a-29998bd77bd3
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 entity: &quot;my_entity_name&quot;,
 uuid: &quot;00d025c9-eda8-4190-a33a-29998bd77bd3&quot;,
 state: &quot;{\&quot;b\&quot;: Integer(39),\&quot;a\&quot;: Integer(-38),}&quot;,
 message: &quot;Entity my_entity_name with Uuid 00d025c9-eda8-4190-a33a-29998bd77bd3 updated&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<h2 id="match-update-1"><a class="header" href="#match-update-1"><code>MATCH UPDATE</code></a></h2>
<p><a href="./sec-4-wql.html#match-update">MATCH UPDATE WQL Reference</a></p>
<p>Updates entity only if precondition condition is matched. This transaction is significantly slower than other updates.</p>
<p>Example request:</p>
<pre><code class="language-sql">MATCH ALL(a &lt; 0, b &gt;= 3) 
UPDATE my_entity_name 
SET {a: 123, g: NiL,} 
INTO 00d025c9-eda8-4190-a33a-29998bd77bd3
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 entity: &quot;my_entity_name&quot;,
 uuid: &quot;00d025c9-eda8-4190-a33a-29998bd77bd3&quot;,
 state: &quot;{\&quot;b\&quot;: Integer(39),\&quot;a\&quot;: Integer(123),\&quot;g\&quot;: Nil,}&quot;,
 message: &quot;Entity my_entity_name with Uuid 00d025c9-eda8-4190-a33a-29998bd77bd3 updated&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<h2 id="delete-1"><a class="header" href="#delete-1"><code>DELETE</code></a></h2>
<p><a href="./sec-4-wql.html#delete">DELETE WQL Reference</a></p>
<p>Deletes the last entity event for an ID, that is, it deletes the last state of an entity map. The deleted state is preserved in the database but cannot be queried anymore.</p>
<p>If you have, for example, one update on your entity, it will roll back to the <code>INSERT</code> event. 
However, if you have only an <code>INSERT</code> event then your state will become an empty hashmap. </p>
<p>Example request: </p>
<pre><code class="language-sql">DELETE 00d025c9-eda8-4190-a33a-29998bd77bd3 FROM my_entity_name
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 entity: &quot;my_entity&quot;,
 uuid: Some(&quot;00d025c9-eda8-4190-a33a-29998bd77bd3&quot;),
 message: &quot;Entity my_entity with Uuid 00d025c9-eda8-4190-a33a-29998bd77bd3 deleted&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<h3 id="todos-1"><a class="header" href="#todos-1">TODOs:</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Delete entity with ID at transaction-time</li>
</ul>
<h2 id="evict-1"><a class="header" href="#evict-1"><code>EVICT</code></a></h2>
<p><a href="./sec-4-wql.html#evict">EVICT WQL Reference</a></p>
<h3 id="evict-entity-id"><a class="header" href="#evict-entity-id"><code>EVICT ENTITY ID</code>:</a></h3>
<p>Removes all occurrences of an entity map with the given ID. </p>
<p>Example request </p>
<pre><code class="language-sql">EVICT 00d025c9-eda8-4190-a33a-29998bd77bd3 from my_entity_name
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 entity: &quot;my_entity&quot;,
 uuid: Some(&quot;00d025c9-eda8-4190-a33a-29998bd77bd3&quot;),
 message: &quot;Entity my_entity with id 6ac9d1bb-2b0c-4631-bc05-682ab4ae8306 evicted&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>For now it only deletes the access to the entity history.</p>
</blockquote>
<h3 id="evict-entity"><a class="header" href="#evict-entity"><code>EVICT ENTITY</code>:</a></h3>
<p>Evicts all entity ids registries from entity tree and removes entity tree key, which means entity tree does not contain the key for the evicted entity: Similar to SQL <code>DROP TABLE &lt;entity&gt;</code>. </p>
<p>Example request: </p>
<pre><code class="language-sql">EVICT my_entity
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 entity: &quot;my_entity&quot;,
 uuid: None,
 message: &quot;Entity my_entity evicted&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Query is the name of all operations that read the database, like <code>SELECT, CHECK</code>. This is done by sending a <code>POST</code> request to endpoint <code>&lt;ip&gt;:1438/wql/query</code>. An example request would be <code>curl -X POST -H &quot;Content-Type: application/wql&quot; &lt;ip&gt;:1438/wql/query -d 'SELECT * FROM my_entity'</code>. In <code>release mode</code> it is necessary to use header <code>Authorization: Bearer &lt;your session token&gt;</code> for this endpoint.</p>
<blockquote>
<p><strong>Reminder</strong>
A comma is required at the end of every data structure representation.
Ex.: <code>{a: 123, b: 456,}</code>, <code>#{a, b, c,}</code>, <code>(a, b, c,)</code>. 
No need for <code>;</code> at the end of each expression.</p>
</blockquote>
<h2 id="check-1"><a class="header" href="#check-1"><code>CHECK</code></a></h2>
<p><a href="./sec-4-wql.html#check">CHECK WQL Reference</a></p>
<p>Checks for encrypted data, in entity map, validity. It requires an entity tree name after <code>FROM</code> and an entity id as Uuid after <code>ID</code>. This transaction only works with keys that are encrypted and it serves to verify if the passed values are <code>true</code> of <code>false</code> against encrypted data. </p>
<p>Considering entity tree key <code>my_entity_name</code> with entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code> with entity map <code>{pswd: Hash(&quot;my-password&quot;), name: &quot;Julia&quot;}</code></p>
<h3 id="example-1"><a class="header" href="#example-1">Example 1:</a></h3>
<p>Example request: </p>
<pre><code class="language-sql">CHECK {pswd: \&quot;my-password\&quot;,} 
FROM my_entity_name ID 48c7640e-9287-468a-a07c-2fb00da5eaed
</code></pre>
<p>Example  response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{&quot;pswd&quot;: true,}
<span class="boring">}
</span></code></pre></pre>
<h3 id="exmample-2"><a class="header" href="#exmample-2">Exmample 2:</a></h3>
<p>Example request: </p>
<pre><code class="language-sql">CHECK {pswd: \&quot;my-password\&quot;, ssn: &quot;1234&quot;,} 
FROM my_entity_name ID 48c7640e-9287-468a-a07c-2fb00da5eaed
</code></pre>
<p>Example  response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 error_type: &quot;CheckNonEncryptedKeys&quot;,
 error_message: &quot;CHECK can only verify encrypted keys: [\&quot;ssn\&quot;]&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<h3 id="example-3"><a class="header" href="#example-3">Example 3:</a></h3>
<p>Example request: </p>
<pre><code class="language-sql">CHECK {pswd: \&quot;your-password\&quot;,} 
FROM my_entity_name ID 48c7640e-9287-468a-a07c-2fb00da5eaed
</code></pre>
<p>Example  response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{&quot;pswd&quot;: false,}
<span class="boring">}
</span></code></pre></pre>
<h2 id="select-1"><a class="header" href="#select-1"><code>SELECT</code></a></h2>
<p><a href="./sec-4-wql.html#select">SELECT WQL Reference</a></p>
<p>This is the way to query entities from WooriDB. Similar to SQL and SparQL <code>SELECT</code>. There are several different keywords that can be combined with <code>SELECT</code>, a few examples are:</p>
<blockquote>
<p><code>*</code> and <code>#{keys...}</code> can be used in all select modes.</p>
</blockquote>
<h3 id="selecting-all-entity-map-keys-from-entity-tree-key"><a class="header" href="#selecting-all-entity-map-keys-from-entity-tree-key">SELECTing all entity map keys FROM entity tree key:</a></h3>
<p>Same as SQL using the token <code>*</code> will defined that all keys in the entity map will be returned. The query <code>SELECT * FROM entity_name</code> selects  all entity ids and entity maps found inside entity tree key <code>entity_name</code>. It is equivalent to SQL's <code>Select * From table</code>. </p>
<p>Example request: <code>SELECT * from my_entity_name</code>. </p>
<p>Example response:</p>
<blockquote>
<p>This query will return a <code>BTreeMap&lt;Uuid, HashMap&lt;String, Types&gt;&gt;</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
  48c7640e-9287-468a-a07c-2fb00da5eaed: 
    {a: 123, b: 43.3, c: &quot;hello&quot;, d: &quot;world&quot;,}, 
  57c7640e-9287-448a-d07c-3db01da5earg: 
    {a: 456, b: 73.3, c: &quot;hello&quot;, d: &quot;brasil&quot;,}, 
  54k6640e-5687-445a-d07c-5hg61da5earg: 
    {a: 789, b: 93.3, c: &quot;hello&quot;, d: &quot;korea&quot;,},
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="selecting-a-set-of-entity-map-keys-from-entity-tree-key"><a class="header" href="#selecting-a-set-of-entity-map-keys-from-entity-tree-key">SELECTing a set of entity map keys FROM entity tree key:</a></h3>
<p>Differently from SQL, WQL requires the keys to be inside a set like <code>#{a, b, c,}</code>, which will return only the keys <code>a, b, c</code>. It is equivalent to <code>SELECT a, b, c FROM table</code>. </p>
<p>Example request: <code>SELECT #{a, b, c,} FROM my_entity_name</code>. </p>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    48c7640e-9287-468a-a07c-2fb00da5eaed: 
        {a: 123, b: 43.3, c: &quot;hello&quot;,}, 
    57c7640e-9287-448a-d07c-3db01da5earg: 
        {a: 456, b: 73.3, c: &quot;hello&quot;,}, 
    54k6640e-5687-445a-d07c-5hg61da5earg: 
        {a: 789, b: 93.3, c: &quot;hello&quot;,},
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="selecting-one-entity-map-from-entity-tree-key"><a class="header" href="#selecting-one-entity-map-from-entity-tree-key">SELECTing one entity map FROM entity tree key:</a></h3>
<p>Select one entity map (by its ID) from entity tree <code>my_entity</code>. By including the key <code>ID</code> after the <code>FROM entity_name</code> it is possible to select a single entity. The content for <code>ID</code>is the entity id's Uuid. It is equivalent to SQL's <code>Select * From table WHERE id = &lt;uuid&gt;</code>. </p>
<p>Example request <code>SELECT * from my_entity_name ID 48c7640e-9287-468a-a07c-2fb00da5eaed</code>. </p>
<p>Example response:</p>
<blockquote>
<p>It will return only the entity map contained inside inside entity id <code>48c7640e-9287-468a-a07c-2fb00da5eaed</code>.
<code>{a: 123, b: 43.3, c: \&quot;hello\&quot;, d: \&quot;world\&quot;,}</code>.</p>
</blockquote>
<h3 id="selecting-a-set-of-entities-ids-and-maps-from-entity-tree-key"><a class="header" href="#selecting-a-set-of-entities-ids-and-maps-from-entity-tree-key">SELECTing a set of entities IDs and maps FROM entity tree key:</a></h3>
<p>Select a few entities maps (by their IDs) from entity tree <code>my_entity</code>. Key <code>IN</code> receives a set of Uuids</p>
<p>Example request: </p>
<pre><code class="language-sql">SELECT #{a, b, c,} 
FROM my_entity_name 
IDS IN #{48c7640e-9287-468a-a07c-2fb00da5eaed, 57c7640e-9287-448a-d07c-3db01da5earg}
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    48c7640e-9287-468a-a07c-2fb00da5eaed: 
        {a: 123, b: 43.3, c: &quot;hello&quot;,}, 
    57c7640e-9287-448a-d07c-3db01da5earg: 
        {a: 456, b: 73.3, c: &quot;hello&quot;,}, 
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="selecting-the-last-entity-map-for-entity-id-at-datetimeutc-from-entity-tree-key"><a class="header" href="#selecting-the-last-entity-map-for-entity-id-at-datetimeutc-from-entity-tree-key">SELECTing the last entity map for entity id at DATETIME<UTC> FROM entity tree key:</a></h3>
<p>Select an entity on a defined past day using the <code>WHEN AT</code> keys.  Key <code>WHEN AT</code> is the date to search. Time will be discarded. The <code>ID</code> field can be used before <code>WHEN</code> to define a specific entity id, <code>IDS IN</code> is not supported. Date format should be <code>&quot;2014-11-28T21:00:09+09:00&quot;</code> or <code>&quot;2014-11-28T21:00:09Z&quot;</code>. </p>
<p>Example requests: </p>
<ul>
<li><code>Select * FROM my_entity ID 0a1b16ed-886c-4c99-97c9-0b977778ec13 WHEN AT 2014-11-28T21:00:09+09:00</code> </li>
<li>OR <code>Select #{name,id,} FROM my_entity WHEN AT 2014-11-28T21:00:09Z</code>.</li>
</ul>
<p>Example response:
<code>{a: 34, b: 4.3, c: \&quot;hello\&quot;, d: \&quot;Julia\&quot;,}</code></p>
<h3 id="todos-2"><a class="header" href="#todos-2">TODOs:</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Support <code>IDS IN</code></li>
</ul>
<h3 id="selecting-all-entities-maps-by-id-from-entity-between-two-datetimeutc"><a class="header" href="#selecting-all-entities-maps-by-id-from-entity-between-two-datetimeutc">SELECTing all entities maps BY ID FROM ENTITY between two DATETIME<UTC>:</a></h3>
<p>Select all occurrences of an entity id from entity tree <code>entity_name</code> in a time range. The time range must be on the same day as <code>WHEN START 2014-11-28T09:00:09Z END 2014-11-28T21:00:09Z</code>. </p>
<ul>
<li>Key <code>WHEN</code> defines it as a temporal query.</li>
<li>Key <code>START</code> is the <code>DateTime&lt;Utc&gt;</code> to start the range query.</li>
<li>Key <code>END</code> is the <code>DateTime&lt;Utc&gt;</code> to end the range query.</li>
<li>Same day validation occurs. Returning the error message <code>&quot;START date and END date should be the same date.&quot;</code>.</li>
<li><code>IDS IN</code> will not be supported as the wuery is too extensive.</li>
</ul>
<p>Example request: </p>
<pre><code class="language-sql">SELECT * 
FROM entity_name 
ID 0a1b16ed-886c-4c99-97c9-0b977778ec13 
WHEN START 2014-11-28T09:00:09Z END 2014-11-28T21:00:09Z
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    &quot;2014-11-28T09:00:09Z&quot;: 
        {a: 34, b: 4.3, c: &quot;hello&quot;, d: &quot;Julia&quot;,},
    &quot;2014-11-28T13:00:09Z&quot;: 
        {a: 23, b: -3.3, c: &quot;hello&quot;, d: &quot;World&quot;,},
    &quot;2014-11-28T19:00:09Z&quot;: 
        {a: 78, b: 67.3, c: &quot;hello&quot;, d: &quot;Julia&quot;,},
    &quot;2014-11-28T21:00:09Z&quot;:
        {a: 123, b: 43.3, c: &quot;hello&quot;, d: &quot;Gasp&quot;,},
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="selecting-entities-ids-and-maps-from-entity-tree-key-where-conditions-are-satisfied"><a class="header" href="#selecting-entities-ids-and-maps-from-entity-tree-key-where-conditions-are-satisfied">SELECTing entities ids and maps FROM entity tree key WHERE conditions are satisfied</a></h3>
<p>This is probably the most different part in relation to SQL as it is inspired by SparQL and Crux/Datomic datalog. Selects entities ids and maps with positive WHERE clauses. Key <code>WHERE</code> receives all clauses inside a <code>{...}</code> block.</p>
<p>To use <code>select</code> with the <code>where</code> clause you can use the following expression:</p>
<ul>
<li><code>SELECT * FROM my_entity WHERE {&lt;clauses&gt;}</code> </li>
</ul>
<h4 id="example-1-1"><a class="header" href="#example-1-1">Example 1:</a></h4>
<p>Example Request:</p>
<pre><code class="language-sql">SELECT * FROM test_entity 
WHERE {
    ?* test_entity:age ?age, 
    ?* test_entity:race ?race, 
    (&gt; ?age 25), 
    (in ?race &quot;Black&quot; &quot;brown&quot;),
}
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
 &quot;08824242-8098-4253-a384-987ff8d78c7d&quot;: {
  &quot;race&quot;: String(&quot;Black&quot;),
  &quot;origin&quot;: String(&quot;Africa&quot;),
  &quot;age&quot;: Integer(34),
  &quot;name&quot;: String(&quot;Diego F&quot;),
 },
 &quot;ea3228d0-0164-453b-bae2-f726c4a9b979&quot;: {
  &quot;origin&quot;: String(&quot;Bukhara&quot;),
  &quot;race&quot;: String(&quot;brown&quot;),
  &quot;age&quot;: Integer(33),
  &quot;name&quot;: String(&quot;julia naomi&quot;),
 },
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="example-2"><a class="header" href="#example-2">Example 2:</a></h4>
<p>Example request:</p>
<pre><code class="language-sql">SELECT * FROM test_entity 
WHERE {
    ?* test_entity:age ?age, 
    (between ?age 18 27),
}
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
 &quot;475fab3b-b023-4f6c-a18e-7e8b25b84a28&quot;: {
  &quot;age&quot;: Integer(25),
  &quot;name&quot;: String(&quot;Otavio&quot;),
  &quot;origin&quot;: String(&quot;Brasil&quot;),
  &quot;race&quot;: String(&quot;Multiracial&quot;),
 },
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="todos-3"><a class="header" href="#todos-3">TODOs:</a></h4>
<ul>
<li><input disabled="" type="checkbox"/>
Support temporality for where clause</li>
</ul>
<h3 id="select-todos---functions-that-couldwill-be-implemented-from-relation-algebra"><a class="header" href="#select-todos---functions-that-couldwill-be-implemented-from-relation-algebra">SELECT TODOs - Functions that could/will be implemented from Relation Algebra:</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Projection</li>
<li><input disabled="" type="checkbox"/>
Union</li>
<li><input disabled="" type="checkbox"/>
Intersection</li>
<li><input disabled="" type="checkbox"/>
Difference (SQL's EXCEPT?)</li>
<li><input disabled="" type="checkbox"/>
Join</li>
<li><input disabled="" type="checkbox"/>
Product (SQL's CROSS JOIN?)</li>
<li><input disabled="" type="checkbox"/>
Rename</li>
<li><input disabled="" type="checkbox"/>
Assign</li>
<li><input disabled="" type="checkbox"/>
Dedup</li>
<li><input disabled="" type="checkbox"/>
Sort</li>
<li><input disabled="" type="checkbox"/>
Aggregate</li>
<li><input disabled="" type="checkbox"/>
Division</li>
</ul>
<h1 id="entity-history"><a class="header" href="#entity-history">Entity History</a></h1>
<p>Entity history is one of the main features of WooriDB. It receives an <code>entity_key</code> name and an <code>entity_id</code> which will return the whole history of <code>(DateTime&lt;Utc&gt;, entity_map)</code> for the <code>entity_id</code> in the entity tree for key <code>entity_key</code>. This is done by sending a <code>POST</code> request to endpoint <code>&lt;ip&gt;:1438/entity-history</code>. An example request would be <code>curl -X POST -H &quot;Content-Type: application/wql&quot; &lt;ip&gt;:1438/entity-history -d '(entity_key: &quot;entity_tree_key&quot;, entity_id: &quot;&lt;some-Uuid&gt;&quot;,)'</code>. In <code>release mode</code> it is necessary to use header <code>Authorization: Bearer &lt;your session token&gt;</code> for this endpoint. </p>
<p>Example request: </p>
<pre><code class="language-ron">(entity_key: &quot;entity_tree_key&quot;, entity_id: &quot;dc3069e7-2a22-4fbc-ae05-f78a807239c0&quot;,)
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
&quot;2021-03-02T05:00:19.813514240Z&quot;: {
    &quot;a&quot;: Integer(123),
    &quot;b&quot;: Float(12.3),
},
&quot;2021-03-02T05:00:19.816357939Z&quot;: {
    &quot;b&quot;: Float(12.3),
    &quot;a&quot;: Integer(123),
},
&quot;2021-03-02T05:00:19.817189987Z&quot;: {
    &quot;b&quot;: Float(12.3),
    &quot;c&quot;: Boolean(true),
    &quot;a&quot;: Integer(34),
},
&quot;2021-03-02T05:00:19.818031113Z&quot;: {
    &quot;b&quot;: Float(12.3),
    &quot;a&quot;: Integer(321),
    &quot;c&quot;: Char('h'),
},}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>This response is considering the following events:</li>
</ul>
<ol>
<li><code>INSERT {a: 123, b: 12.3,} INTO entity_tree_key</code>.</li>
<li><code>UPDATE entity_tree_key SET {{a: 12, c: Nil,}} INTO dc3069e7-2a22-4fbc-ae05-f78a807239c0</code>. Note that this event does not appear due to DELETE.</li>
<li><code>Delete dc3069e7-2a22-4fbc-ae05-f78a807239c0 FROM entity_tree_key</code>. Entity map state is the same as the previous state, therefore &quot;2021-03-02T05:00:19.813514240Z&quot; and &quot;2021-03-02T05:00:19.816357939Z&quot; have equal content.</li>
<li><code>UPDATE entity_tree_key SET {{a: 34, c: true,}} INTO dc3069e7-2a22-4fbc-ae05-f78a807239c0</code>.</li>
<li><code>UPDATE entity_tree_key SET {{a: 321, c: 'h',}} INTO dc3069e7-2a22-4fbc-ae05-f78a807239c0</code>.</li>
</ol>
<h2 id="entity-history-with-time-ranges"><a class="header" href="#entity-history-with-time-ranges">Entity history with time ranges</a></h2>
<p>There are two extra parameters that can be used with <code>entity-history</code>, they are <code>start_datetime</code> and <code>end_datetime</code>. Both parameters are optional and if they are present they will define the time limits of the query. <code>start_datetime</code> is the beginning of the time range query while <code>end_datetime</code> is the ending of the time range query. If we used <code>start_datetime</code> and <code>end_datetime</code> for the previous example as <code>curl -X POST -H &quot;Content-Type: application/wql&quot; &lt;ip&gt;:1438/entity-history -d '(entity_key: &quot;entity_tree_key&quot;, entity_id: &quot;&lt;some-Uuid&gt;&quot;, start_datetime: Some(&quot;2021-03-02T05:00:19.816357937Z&quot;), end_datetime: Some(&quot;2021-03-02T05:00:19.817189988Z&quot;),)'</code> we would have the following result:</p>
<p>Example request: </p>
<pre><code class="language-ron">(
    entity_key: &quot;entity_tree_key&quot;, 
    entity_id: &quot;dc3069e7-2a22-4fbc-ae05-f78a807239c0&quot;,  
    start_datetime: Some(&quot;2021-03-02T05:00:19.816357937Z&quot;), 
    end_datetime: Some(&quot;2021-03-02T05:00:19.817189988Z&quot;),
)
</code></pre>
<p>Example response:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
&quot;2021-03-02T05:00:19.816357939Z&quot;: {
    &quot;b&quot;: Float(12.3),
    &quot;a&quot;: Integer(123),
},
&quot;2021-03-02T05:00:19.817189987Z&quot;: {
    &quot;b&quot;: Float(12.3),
    &quot;c&quot;: Boolean(true),
    &quot;a&quot;: Integer(34),
},,}
<span class="boring">}
</span></code></pre></pre>
<h1 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h1>
<p>Woori DB has a variety of Error messages, from WQL when parsing the transaction or the query to some internal database errors. Here are listed expected messages:</p>
<h2 id="wooridb-errors"><a class="header" href="#wooridb-errors">WooriDB Errors:</a></h2>
<h3 id="example-errors-as-response"><a class="header" href="#example-errors-as-response">Example errors as response:</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(
 error_type: &quot;CheckNonEncryptedKeys&quot;,
 error_message: &quot;CHECK can only verify encrypted keys: [\&quot;ssn\&quot;]&quot;,
)
<span class="boring">}
</span></code></pre></pre>
<h3 id="error-types"><a class="header" href="#error-types">Error types:</a></h3>
<ul>
<li><code>Io(io::Error)</code> - Failed to read or write file.</li>
<li><code>QueryFormat(String)</code> - WQL error.</li>
<li><code>EntityAlreadyCreated(&lt;entity_name&gt;)</code> - Entity <code>entity_name</code> already created in the database.</li>
<li><code>EntityNotCreated(&lt;entity_name&gt;)</code> - tx or query at entity tree dooes not contain key <code>entity_name</code>.</li>
<li><code>EntityNotCreatedWithUniqueness(&lt;entity_name&gt;)</code> - this error only occurs if a failed write to the bank happened. Migration to fix data inconsistency may be needed.</li>
<li><code>Serialization(ron::Error)</code> - Ron serialization error in wql context.</li>
<li><code>UuidNotCreatedForEntity(&lt;entity_name&gt;, Uuid)</code> - If you try to <code>UPDATE/DELETE/EVICT/SELECT</code> an Uuid that <code>entity_name</code> does not contain.</li>
<li><code>FailedToParseState</code> - Failed to read log file state/entity map.</li>
<li><code>FailedToParseRegistry</code> - Failed to read log file registry information</li>
<li><code>UnknownCondition</code> - <code>MATCH UPDATE</code> has an unknown condition (<code>==</code>, <code>&gt;=</code>, <code>&lt;</code>, etc).</li>
<li><code>FailedMatchCondition</code> - <code>MATCH UPDATE</code> internal service error while processing conditions.</li>
<li><code>DuplicatedUnique(&lt;entity_name&gt;, &lt;entity_map_key&gt;, Types)</code> - This means that <code>Types</code> is already present at <code>entity_map_key</code> for entity tree <code>entity_name</code>.</li>
<li><code>SelectBadRequest</code> - Select operation done at <code>/wql/tx</code>. Select operations are done at <code>/wql/query</code>.</li>
<li><code>NonSelectQuery</code> - Tx operation done at <code>/wql/query</code>. Tx operations are done at <code>/wql/tx</code>.</li>
<li><code>ActixMailbox(MailboxError)</code> - Internal server error meaning that some actor mailbox crashed.</li>
<li><code>LockData</code> - Failed to get a lock on Data</li>
<li><code>Ron(ron::Error)</code> - Ron serialization error that occured in user creation.</li>
<li><code>InvalidUuid(uuid::Error)</code> - Uuid could not be parsed.</li>
<li><code>UpdateContentEncryptKeys(Vec&lt;keys&gt;)</code> - <code>UPDATE CONTENT</code> cannot update encrypted <code>keys</code>.</li>
<li><code>CheckNonEncryptedKeys(Vec&lt;keys&gt;)</code> - Cannot <code>CHECK</code> non encrypted <code>keys</code>.</li>
<li><code>DateTimeParse(chrono::ParseError)</code> - failed to parse input <code>DateTime&lt;UTC&gt;</code>.</li>
<li><code>FailedToParseDate</code> - failed to parse log file saved date.</li>
<li><code>AdminNotConfigured</code> - Admin is not configured at release mode, please check <a href="./sec-5-auth.html">auth section</a> for more info.</li>
<li><code>AuthBadRequest</code> - Authentication &amp; Authorization error.</li>
<li><code>FailedToCreateUser</code> - Failed to create new user.</li>
<li><code>Unknown</code> - Unknown error.</li>
</ul>
<h2 id="wql-parsing"><a class="header" href="#wql-parsing">WQL Parsing</a></h2>
<ul>
<li>
<p><code>Query symbol error</code>: </p>
<ul>
<li>&quot;Symbol <code>{symbol_name}</code> not implemented&quot;. Symbol name are the start of the query, like <code>SELECT, CHECK, CREATE, ISNERT</code>.</li>
</ul>
</li>
<li>
<p><code>Keyword error</code>:</p>
<ul>
<li><code>CREATE</code>: Keyword ENTITY is required for CREATE&quot;
<ul>
<li>&quot;Correct wording is ENCRYPT&quot; for <code>CREATE ENTITY ENCRYPT</code></li>
<li>&quot;Correct wording is UNIQUES&quot; for <code>CREATE ENTITY UNIQUES</code>.</li>
</ul>
</li>
<li><code>UPDATE</code>: &quot;UPDATE type is required after entity. Keywords are SET or CONTENT&quot;
<ul>
<li>&quot;Keyword INTO is required for UPDATE&quot;</li>
<li>&quot;Keyword INTO is required for MATCH UPDATE&quot;</li>
<li>&quot;UPDATE keyword is required for MATCH UPDATE&quot;</li>
<li>&quot;MATCH UPDATE type is required after entity. Keyword is SET&quot;. Use <code>SET</code> as update type in <code>MATCH</code>.</li>
</ul>
</li>
<li><code>SELECT/CHECK</code>: &quot;Keyword FROM is required for CHECK&quot;
<ul>
<li>&quot;Keyword FROM is required for SELECT&quot;</li>
<li>&quot;WHEN not allowed after IDS IN&quot;</li>
<li>&quot;Keyword AT is required after WHEN&quot;</li>
<li>&quot;Keyword IN is required after IDS to define a set of uuids&quot;</li>
<li>&quot;Keyword ID/IDS is required to set an uuid in SELECT&quot;.</li>
</ul>
</li>
<li><code>EVICT/DELETE/INSERT</code>: &quot;Keyword FROM is required for DELETE&quot;
<ul>
<li>&quot;Keyword INTO is required for INSERT&quot;</li>
<li>&quot;Keyword FROM is required to EVICT an UUID&quot;.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Argument format error</code>:</p>
<ul>
<li>&quot;Arguments set should start with <code>#{</code> and end with <code>}</code>&quot;</li>
<li>&quot;Entity map should start with <code>{</code> and end with <code>}</code>&quot; occurs mostly with <code>INSERT and UPDATE</code>.</li>
<li>&quot;Field ID must be a UUID v4&quot;</li>
<li><code>SELECT</code>: &quot;Encrypted arguments cannot be set to UNIQUE&quot;
<ul>
<li>&quot;SELECT expression should be followed by <code>*</code> for ALL keys or <code>#{key_names...}</code> for some keys&quot; and &quot;SELECT arguments set should start with <code>#{</code> and end with <code>}</code>&quot;</li>
<li>&quot;Uuids in <code>IDS IN</code> are reuired to be inside a <code>#{</code> and <code>}</code>&quot;</li>
<li>&quot;START date and END date should be the same date.&quot;</li>
<li>&quot;WHERE clauses must be contained inside <code> {...}</code>&quot;</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Required content</code>:</p>
<ul>
<li>&quot;MATCH requires ALL or ANY symbols&quot;. It is necessary to include <code>ANY</code> or <code>ALL</code> conditions after <code>MATCH</code> keyword.</li>
<li>&quot;Entity UUID is required for DELETE&quot;</li>
<li><code>Entity name</code>: 
<ul>
<li>&quot;Entity name is required after FROM&quot;</li>
<li>&quot;Entity name is required for SELECT&quot;</li>
<li>&quot;Entity name is required after INTO&quot;</li>
<li>&quot;Entity name is required for UPDATE&quot;</li>
<li>&quot;Entity name is required for EVICT&quot;</li>
<li>&quot;Entity name is required for MATCH UPDATE&quot;</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Parse error</code>:</p>
<ul>
<li>&quot;Couldn't create uuid from {some-text}. Error: {Uuid::Error}&quot;</li>
<li>&quot;Couldn't parse UPDATE query&quot;. <code>SET</code> or <code>CONTENT</code> were not found after <code>UPDATE</code></li>
<li>&quot;Couldn't parse MATCH UPDATE query&quot;</li>
<li>&quot;Entity name cannot contain <code>-</code>&quot;. Entity name should contain only alphanumeric and <code>_</code> chars.</li>
<li>&quot;Key must be an alphanumeric value&quot; or contain <code>_</code>.</li>
<li>&quot;Hash cannot be hashed&quot; and &quot;Nil cannot be hashed&quot;. <code>Types::Hash</code> and <code>Types::Nil</code> cannot be hashed.</li>
<li>&quot;Not able to parse match argument&quot;. Match condition has wrong argument type.</li>
<li>&quot;Unidentified Match Condition&quot;. Could not identify match condition.</li>
<li>&quot;Entity HashMap could not be created&quot;</li>
<li>&quot;Value Type could not be created from {some value}&quot;. Could not create <code>Types</code> from <code>some value</code>.</li>
<li>&quot;WHERE clause cannot be empty&quot;</li>
</ul>
</li>
</ul>
<h2 id="issues"><a class="header" href="#issues">Issues:</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://github.com/naomijub/wooridb/issues/79">Split <code>AuthBadRequest</code> into <code>AuthenticationBadRequest</code> and <code>AuthorizationBadRequest</code></a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
